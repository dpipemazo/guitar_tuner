#  Atlys
Net xps_uart16550_0_sin_pin LOC=A16  |  IOSTANDARD=LVCMOS33;
Net xps_uart16550_0_sout_pin LOC=B16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<0> LOC=E4  |  IOSTANDARD=LVCMOS18;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<1> LOC=T5  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<2> LOC=R5  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<3> LOC=P12  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<4> LOC=P15  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<5> LOC=C14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<6> LOC=D14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_DIP_Switches_8Bits_GPIO_IO_I_pin<7> LOC=A10  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<0> LOC=N12  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<1> LOC=P16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<2> LOC=D4  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<3> LOC=M13  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<4> LOC=L14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<5> LOC=N14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<6> LOC=M14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_LEDs_8Bits_GPIO_IO_O_pin<7> LOC=U18  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Push_Buttons_5Bits_GPIO_IO_I_pin<0> LOC=N4  |  IOSTANDARD=LVCMOS18;
Net fpga_0_Push_Buttons_5Bits_GPIO_IO_I_pin<1> LOC=P4  |  IOSTANDARD=LVCMOS18;
Net fpga_0_Push_Buttons_5Bits_GPIO_IO_I_pin<2> LOC=P3  |  IOSTANDARD=LVCMOS18;
Net fpga_0_Push_Buttons_5Bits_GPIO_IO_I_pin<3> LOC=F6  |  IOSTANDARD=LVCMOS18;
Net fpga_0_Push_Buttons_5Bits_GPIO_IO_I_pin<4> LOC=F5  |  IOSTANDARD=LVCMOS18;

Net fpga_0_MCB_DDR2_rzq_pin IOSTANDARD = LVCMOS18_JEDEC;
Net fpga_0_MCB_DDR2_zio_pin IOSTANDARD = LVCMOS18_JEDEC;

Net PS2_Devices_PS2_Keyboard_CLK  LOC = P17  |  SLEW = SLOW  |  DRIVE = 2  |  IOSTANDARD = LVCMOS33 | PULLUP;
Net PS2_Devices_PS2_Keyboard_DATA LOC = N15  |  SLEW = SLOW  |  DRIVE = 2  |  IOSTANDARD = LVCMOS33 | PULLUP;
Net PS2_Devices_PS2_Mouse_CLK  LOC = P18  |  SLEW = SLOW  |  DRIVE = 2  |  IOSTANDARD = LVCMOS33 | PULLUP;
Net PS2_Devices_PS2_Mouse_DATA LOC = N18  |  SLEW = SLOW  |  DRIVE = 2  |  IOSTANDARD = LVCMOS33 | PULLUP;

Net phy_reset_component_0_PhyResetOut_pin LOC=G13  |  TIG  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_MII_TX_CLK_0_pin LOC=K16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<0> LOC=H16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<1> LOC=H13  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<2> LOC=K14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<3> LOC=K13  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<4> LOC=J13  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<5> LOC=G14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<6> LOC=H12  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TXD_0_pin<7> LOC=K12  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TX_EN_0_pin LOC=H15  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TX_ER_0_pin LOC=G18  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_TX_CLK_0_pin LOC=L12  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<0> LOC=G16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<1> LOC=H14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<2> LOC=E16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<3> LOC=F15  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<4> LOC=F14  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<5> LOC=E18  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<6> LOC=D18  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RXD_0_pin<7> LOC=D17  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RX_DV_0_pin LOC=F17  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RX_ER_0_pin LOC=F18  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_GMII_RX_CLK_0_pin LOC=K15  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_MDC_0_pin LOC=F16  |  IOSTANDARD=LVCMOS33;
Net fpga_0_Soft_TEMAC_MDIO_0_pin LOC=N17  |  IOSTANDARD=LVCMOS33;
Net fpga_0_clk_1_sys_clk_pin TNM_NET = sys_clk_pin;
TIMESPEC TS_sys_clk_pin = PERIOD sys_clk_pin 100000 kHz;
Net fpga_0_clk_1_sys_clk_pin LOC=L15  |  IOSTANDARD=LVCMOS33;
Net fpga_0_rst_1_sys_rst_pin TIG;
Net fpga_0_rst_1_sys_rst_pin LOC=T15  |  IOSTANDARD=LVCMOS33;

Net ac97_if_0_BITCLK_pin LOC = L13 | IOSTANDARD = LVCMOS33;
Net ac97_if_0_SDATA_IN_pin LOC = T18 | IOSTANDARD = LVCMOS33;
Net ac97_if_0_SDATA_OUT_pin LOC = N16 | IOSTANDARD = LVCMOS33;
Net ac97_if_0_SYNC_pin  LOC = U17 | IOSTANDARD = LVCMOS33;
Net ac97_if_0_RESET_N_pin LOC = T17 | IOSTANDARD = LVCMOS33;


Net d_usb_epp_dstm_0_DB<7> LOC = C5 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<6> LOC = A4 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<5> LOC = B4 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<4> LOC = A3 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<3> LOC = B3 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<2> LOC = C6 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<1> LOC = D6 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_DB<0> LOC = A2 | IOSTANDARD = LVCMOS33;

Net d_usb_epp_dstm_0_IFCLK_pin LOC = C10 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_STMEN_pin LOC = B2 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_SLWR_pin LOC = E13 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_SLOE_pin LOC = A15 | IOSTANDARD = LVCMOS33;

Net d_usb_epp_dstm_0_FIFOADR_pin<1> LOC = B14 | IOSTANDARD = LVCMOS33;
Net d_usb_epp_dstm_0_FIFOADR_pin<0> LOC = A14 | IOSTANDARD = LVCMOS33;

Net d_usb_epp_dstm_0_PKTEND_pin LOC = C4 | IOSTANDARD = LVCMOS33;

Net d_usb_epp_dstm_0_FLAGC_pin LOC = C15 | IOSTANDARD = LVCMOS33; #FLAGC
Net d_usb_epp_dstm_0_FLAGA_pin LOC = B9 | IOSTANDARD = LVCMOS33; #FLAGA
Net d_usb_epp_dstm_0_FLAGB_pin LOC = A9 | IOSTANDARD = LVCMOS33; #FLAGB
Net d_usb_epp_dstm_0_SLRD_pin LOC = F13 | IOSTANDARD = LVCMOS33; #SLRD
Net d_usb_epp_dstm_0_EPPRST_pin LOC = A5 | IOSTANDARD = LVCMOS33;


Net vhdci_conn_GPIO_IO<0> LOC = U16 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; #BANK 2
Net vhdci_conn_GPIO_IO<1> LOC = U15 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<2> LOC = U13 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<3> LOC = M11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<4> LOC = R11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<5> LOC = T12 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<6> LOC = N10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<7> LOC = M10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<8> LOC = U11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<9> LOC = R10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<10> LOC = U10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<11> LOC = R8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<12> LOC = M8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<13> LOC = U8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<14> LOC = U7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<15> LOC = N7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<16> LOC = T6 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<17> LOC = R7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<18> LOC = N6 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO_IO<19> LOC = U5 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;

Net vhdci_conn_GPIO2_IO<0> LOC = V16 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<1> LOC = V15 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<2> LOC = V13 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<3> LOC = N11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<4> LOC = T11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<5> LOC = V12 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<6> LOC = P11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<7> LOC = N9 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<8> LOC = V11 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<9> LOC = T10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<10> LOC = V10 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<11> LOC = T8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<12> LOC = N8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<13> LOC = V8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<14> LOC = V7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<15> LOC = P8 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<16> LOC = V6 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<17> LOC = T7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<18> LOC = P7 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;
Net vhdci_conn_GPIO2_IO<19> LOC = V5 | IOSTANDARD = LVCMOS33 | SLEW = SLOW | DRIVE = 2 | TIG | PULLUP;

#Net PS2_Monitor_Ports_pin<0> LOC = R3 | IOSTANDARD = LVCMOS33; #JA_D0_P
#Net PS2_Monitor_Ports_pin<1> LOC = T3 | IOSTANDARD = LVCMOS33; #JA_D0_N
#Net PS2_Monitor_Ports_pin<2> LOC = N5 | IOSTANDARD = LVCMOS33; #JA_D2_P
#Net PS2_Monitor_Ports_pin<3> LOC = P6 | IOSTANDARD = LVCMOS33; #JA_D2_N

#NET dvi_out_native_testpattern_0_TMDS_pin<0>  	LOC = R3 | IOSTANDARD = TMDS_33 ; # Blue
#NET dvi_out_native_testpattern_0_TMDSB_pin<0>  	LOC = T3 | IOSTANDARD = TMDS_33 ;
#NET dvi_out_native_testpattern_0_TMDS_pin<1>  	LOC = T4 | IOSTANDARD = TMDS_33 ; # Red
#NET dvi_out_native_testpattern_0_TMDSB_pin<1>  	LOC = V4 | IOSTANDARD = TMDS_33 ;
#NET dvi_out_native_testpattern_0_TMDS_pin<2>  	LOC = N5 | IOSTANDARD = TMDS_33 ; # Green
#NET dvi_out_native_testpattern_0_TMDSB_pin<2>  	LOC = P6 | IOSTANDARD = TMDS_33 ;
#NET dvi_out_native_testpattern_0_TMDS_pin<3> 	LOC = T9 | IOSTANDARD = TMDS_33 ; # Clock
#NET dvi_out_native_testpattern_0_TMDSB_pin<3> 	LOC = V9 | IOSTANDARD = TMDS_33 ;

###########################################
# Setting VCCAUX for TMDS interfaces
###########################################
VCCAUX = 3.3;

NET dvi_out_native_0_TMDS_pin<0>  	LOC = R3 | IOSTANDARD = TMDS_33 ; # Blue
NET dvi_out_native_0_TMDSB_pin<0>  	LOC = T3 | IOSTANDARD = TMDS_33 ;
NET dvi_out_native_0_TMDS_pin<1>  	LOC = T4 | IOSTANDARD = TMDS_33 ; # Red
NET dvi_out_native_0_TMDSB_pin<1>  	LOC = V4 | IOSTANDARD = TMDS_33 ;
NET dvi_out_native_0_TMDS_pin<2>  	LOC = N5 | IOSTANDARD = TMDS_33 ; # Green
NET dvi_out_native_0_TMDSB_pin<2>  	LOC = P6 | IOSTANDARD = TMDS_33 ;
NET dvi_out_native_0_TMDS_pin<3>  	LOC = T9 | IOSTANDARD = TMDS_33 ; # Clock
NET dvi_out_native_0_TMDSB_pin<3>  	LOC = V9 | IOSTANDARD = TMDS_33 ;

NET dvi_in_native_0_TMDS_pin<0> 	   LOC = G9 | IOSTANDARD = TMDS_33; # Blue
NET dvi_in_native_0_TMDSB_pin<0>  	LOC = F9 | IOSTANDARD = TMDS_33;
NET dvi_in_native_0_TMDS_pin<1>  	LOC = B11 | IOSTANDARD = TMDS_33; # Red
NET dvi_in_native_0_TMDSB_pin<1>  	LOC = A11 | IOSTANDARD = TMDS_33;
NET dvi_in_native_0_TMDS_pin<2>  	LOC = B12 | IOSTANDARD = TMDS_33; # Green
NET dvi_in_native_0_TMDSB_pin<2>  	LOC = A12 | IOSTANDARD = TMDS_33;
NET dvi_in_native_0_TMDS_pin<3>  	LOC = D11 | IOSTANDARD = TMDS_33; # Clock
NET dvi_in_native_0_TMDSB_pin<3>  	LOC = C11 | IOSTANDARD = TMDS_33;

#
# Multi-cycle paths
#
#TIMEGRP "bramgrp" = RAMS(*/enc0/pixel2x/dataint<*>);  
#TIMEGRP "fddbgrp" = FFS(*/enc0/pixel2x/db<*>);
#TIMEGRP "bramra" = FFS(*/enc0/pixel2x/ra<*>);

#TIMESPEC "TS_ramdo" = FROM "bramgrp" TO "fddbgrp" TS_PCLK;
#TIMESPEC "TS_ramra" = FROM "bramra" TO "fddbgrp" TS_PCLK;

# I2C
Net I2C_Bus_GPIO_IO<0> LOC = C13 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # JA - SCL
Net I2C_Bus_GPIO_IO<1> LOC = A13 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # JA-SDA
Net I2C_Bus_GPIO_IO<2> LOC =  D9 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # TMDS-TX-SCL
Net I2C_Bus_GPIO_IO<3> LOC =  C9 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # TMDS-TX-SDA
Net I2C_Bus_GPIO_IO<4> LOC = M16 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # TMDS-RX-SCL
Net I2C_Bus_GPIO_IO<5> LOC = M18 | IOSTANDARD = LVCMOS33 |  SLEW = SLOW | DRIVE = 2 | TIG | PULLUP; # TMDS-RX-SDA

# SPI - Flash Memory
Net quad_spi_if_0_C_pin LOC = R15 | IOSTANDARD = LVCMOS33 | PULLUP; # IO_L1P_CCLK_2
Net quad_spi_if_0_S_pin LOC = V3  | IOSTANDARD = LVCMOS33; # IO_L65N_CSO_B_2
Net quad_spi_if_0_DQ<0> LOC = T13 | IOSTANDARD = LVCMOS33; # IO_L3N_MOSI_CSI_B_MISO0_2
Net quad_spi_if_0_DQ<1> LOC = R13 | IOSTANDARD = LVCMOS33; # IO_L3P_D0_DIN_MISO_MISO1_2
Net quad_spi_if_0_DQ<2> LOC = T14 | IOSTANDARD = LVCMOS33; # IO_L12P_D1_MISO2_2
Net quad_spi_if_0_DQ<3> LOC = V14 | IOSTANDARD = LVCMOS33; # IO_L12N_D2_MISO3_2

###### Soft_TEMAC
###### Soft_TEMAC
# This is a GMII system
# LlinkTemac0_CLK = plb_v46 clk = host clock = 66.67MHz from clock generator
# Rx/Tx Client clocks are Rx/Tx PHY clocks so CORE Gen PHY clock constraints propagate to Rx/Tx client clock periods
# Time domain crossing constraints (DATAPATHONLY) are set for maximum bus frequency
# allowed by IP which is the maximum option in BSB. For lower bus frequency choice in BSB,
# the constraints are over constrained. Relaxing them for your system may reduce build time.

NET "*Soft_TEMAC*/LlinkTemac0_CLK"   TNM_NET = "LLCLK0"; #name of signal connected to TEMAC LlinkTemac0_CLK input
NET "*Soft_TEMAC*/SPLB_Clk"          TNM_NET = "PLBCLK"; #name of signal connected to TEMAC SPLB_Clk input 

# PLBCLK = LLink clock, so this is a duplicate of TS_LL_CLK0_2_TX_CLIENT_CLK0
#TIMESPEC TS_PLB_2_TXPHY0 = FROM PLBCLK      TO clk_tx_gmii 8000 ps DATAPATHONLY; #constant value based on Ethernet clock
# PLBCLK = LLink clock, so this is a duplicate of TS_TX_CLIENT_CLK0_2_LL_CLK0
#TIMESPEC TS_TXPHY0_2_PLB = FROM clk_tx_gmii  TO PLBCLK    11111 ps DATAPATHONLY; #constant value based on Ethernet clock

# PLBCLK = LLink clock, so this is a duplicate of TS_LL_CLK0_2_RX_CLIENT_CLK0
#TIMESPEC TS_PLB_2_RXPHY0 = FROM PLBCLK      TO clk_rx      8000 ps DATAPATHONLY; #varies based on period of PLB clock   
# PLBCLK = LLink clock, so this is a duplicate of TS_RX_CLIENT_CLK0_2_LL_CLK0
#TIMESPEC TS_RXPHY0_2_PLB = FROM clk_rx      TO PLBCLK      11111 ps DATAPATHONLY; #varies based on period of PLB clock

# PLBCLK = LLink clock, so this constraint is not needed
#TIMESPEC TS_PLB_2_LL0 = FROM PLBCLK  TO  LLCLK0 11111 ps DATAPATHONLY; #constant value based on LocalLink clock                                  
#TIMESPEC TS_LL0_2_PLB = FROM LLCLK0  TO  PLBCLK 11111 ps DATAPATHONLY; #varies based on period of PLB clock                                      

TIMESPEC "TS_LL_CLK0_2_RX_CLIENT_CLK0"  = FROM LLCLK0 TO clk_rx     8000 ps DATAPATHONLY; #constant value based on Ethernet clock
TIMESPEC "TS_LL_CLK0_2_TX_CLIENT_CLK0"  = FROM LLCLK0 TO clk_tx_gmii 8000 ps DATAPATHONLY; #constant value based on Ethernet clock
TIMESPEC "TS_RX_CLIENT_CLK0_2_LL_CLK0"  = FROM clk_rx      TO LLCLK0 11111 ps DATAPATHONLY; #varies based on period of LocalLink clock
TIMESPEC "TS_TX_CLIENT_CLK0_2_LL_CLK0"  = FROM clk_tx_gmii TO LLCLK0 11111 ps DATAPATHONLY; #varies based on period of LocalLink clock

# Rx Clock crossings - Some paths are analyzed by the TS_flow_rx_to_tx constraint also 
# Needed since ts_resync_flops is commented out
TIMESPEC "TS_RX_CLIENT_CLK0_2_GTX_CLK"  = FROM clk_rx     TO clk_gtx    8000 ps DATAPATHONLY; #constant value based on constant 125 MHZ GTX clock 

# This is the same as TS_TX_CLIENT_CLK0_2_LL_CLK0 when PLBCLK = LLCLK0
TIMESPEC "TS_GTX_CLK_2_PLB_CLIENT_CLK"  = FROM clk_gtx TO PLBCLK 11111 ps DATAPATHONLY; #varies based on period of PLB clock               
# This is the same as TS_LL_CLK0_2_TX_CLIENT_CLK0 when PLBCLK = LLCLK0
TIMESPEC "TS_PLB_CLIENT_CLK_2_GTX_CLK"  = FROM PLBCLK TO clk_gtx 8000 ps DATAPATHONLY; #constant value based on constant 125 MHZ GTX clock 

# Locate the Tri-Mode Ethernet MAC instance
# Changed to let tools pick
# INST "*v6_emac" LOC = "TEMAC_X0Y0";

###############################################################################
# CLOCK CONSTRAINTS
# The following constraints are required. If you choose to not use the example
# design level of wrapper hierarchy, the net names should be translated to
# match your design.
###############################################################################

############################################################
# RX Clock period Constraints                              #
############################################################
# Receiver clock period constraints: please do not relax
# Changed NET name
#NET "gmii_rx_clk"     TNM_NET = "clk_rx";
NET "*/GMII_RX_CLK_0" TNM_NET = "clk_rx";
TIMEGRP "rx_clock" = "clk_rx";
TIMESPEC "TS_rx_clk" = PERIOD "rx_clock" 8000 ps HIGH 50 %;

############################################################
# TX Clock period Constraints                              #
############################################################
# Transmitter clock period constraints: please do not relax
# Changed NET name
#NET "gtx_clk*"             TNM_NET  = "clk_gtx";
NET "*/GTX_CLK_0"          TNM_NET  = "clk_gtx";
TIMEGRP "gtx_clock"        = "clk_gtx";
TIMESPEC "TS_gtx_clk"      = PERIOD "gtx_clock" 8000 ps HIGH 50 %;

# Changed NET name
# NET "*tx_gmii_clk"   TNM_NET = "clk_tx_gmii";
NET "*tx_gmii_mii_clk_int_0" TNM_NET = "clk_tx_gmii";
TIMEGRP "tx_clock_gmii" = "clk_tx_gmii";
TIMESPEC "TS_tx_clk_gmii" = PERIOD "tx_clock_gmii" 8000 ps HIGH 50 %;
                                                                        

############################################################
# Host Clock period Constraint                             #
############################################################
# Management Clock period constraints: relax as required
# Example frequency of 90 MHz
# Changed NET name
# NET "host_clk" TNM_NET = "host_clk";
NET "*/SPLB_Clk" TNM_NET = "host_clk";
TIMEGRP "host" = "host_clk" EXCEPT "mdio_logic";
TIMESPEC "TS_host_clk" = PERIOD "host" 11111 ps HIGH 50 %;

############################################################
# External GMII Constraints                                #
############################################################
# GMII Transmitter Constraints:  place flip-flops in IOB
# Changed 'true' to 'force'
INST "*gmii_txd*"                  IOB = force;
INST "*gmii_tx_en"                 IOB = force;
INST "*gmii_tx_er"                 IOB = force;

# GMII Receiver Constraints:  place flip-flops in IOB
# Changed 'true' to 'force'
INST "*rxd_to_mac*"                IOB = force;
INST "*rx_dv_to_mac"               IOB = force;
INST "*rx_er_to_mac"               IOB = force;


############################################################
# The following are required to maximize setup/hold        #
############################################################
# Changed to add Drive strength and INST Name
INST "fpga_0_Soft_TEMAC_GMII_TXD_0_pin_?_OBUF"  SLEW = FAST;
INST "fpga_0_Soft_TEMAC_GMII_TX_EN_0_pin_OBUF"  SLEW = FAST;
INST "fpga_0_Soft_TEMAC_GMII_TX_ER_0_pin_OBUF"  SLEW = FAST;
INST "fpga_0_Soft_TEMAC_GMII_TX_CLK_0_pin_OBUF" SLEW = FAST;



############################################################
# GMII: IODELAY Constraints
############################################################
# Please modify the value of the IDELAY_VALUE
# according to your design.
# For more information on IDELAYCTRL and IODELAY, please
# refer to the Spartan-6 User Guide.
#
INST "*delay_gmii_rx_dv"               IDELAY_VALUE = 12;
INST "*delay_gmii_rx_er"               IDELAY_VALUE = 12;
INST "*data_bus[0].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[1].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[2].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[3].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[4].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[5].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[6].delay_gmii_rxd"     IDELAY_VALUE = 12;
INST "*data_bus[7].delay_gmii_rxd"     IDELAY_VALUE = 12;

# Group IODELAY and IDELAYCTRL components to aid placement
#Changed to remove GROUP
#INST "*delay_gmii_rx_clk"              IODELAY_GROUP = "grp1";
#INST "*delay_gmii_rx_dv"               IODELAY_GROUP = "grp1";
#INST "*delay_gmii_rx_er"               IODELAY_GROUP = "grp1";
#INST "*delay_gmii_rxd"                 IODELAY_GROUP = "grp1";
#INST "*dlyctrl"                        IODELAY_GROUP = "grp1";

#Changed to let the tools pick the LOC
#INST *BUFGMUX_SPEED_CLK                   LOC = BUFGCTRL_X0Y30;

############################################################
# For Setup and Hold time analysis on GMII inputs          #
############################################################

# Identify GMII Rx Pads only.  
# This prevents setup/hold analysis being performed on false inputs,
# eg, the configuration_vector inputs.
# Changed to remove TNM and changed INST Names
#INST "gmii_rxd<?>"                     TNM = IN_GMII; 
#INST "gmii_rx_er"                      TNM = IN_GMII;
#INST "gmii_rx_dv"                      TNM = IN_GMII;

# Define data valid window with respect to the clock.
# The spec states that, worst case, the data is valid 2 ns before the clock edge.
# The worst case it to provide zero hold time (a 2ns window in total)
#Changed to remove TIMEGRP 
#TIMEGRP "IN_GMII" OFFSET         = IN  2 ns VALID 2 ns BEFORE "gmii_rx_clk"; 
# Set to allow for 100ps setup/hold trace delay difference in relation to clock
OFFSET = IN  2.4 ns VALID 2.8 ns BEFORE "fpga_0_Soft_TEMAC_GMII_RX_CLK_0_pin"; 


############################################################
# Reset path constraints                                   #
#  These constraints add a measure of protection against   #
#  metastability and skew in the reset nets.               #
############################################################
# Changed net name in synthesis of xps_ll_temac
NET "*/I_TRIMAC_INST/RXGMIIRSTGENEN.I_SYNC_GMII_MII_RX_RESET_I/RESET_OUT*"  MAXDELAY = 6100 ps;
NET "*/I_TRIMAC_INST/I_SYNC_GMII_MII_TX_RESET_I/RESET_OUT*"                 MAXDELAY = 6100 ps;
NET "*/I_TRIMAC_INST/G_SYNC_MGMT_RESET.I_SYNC_MGMT_RESET_HOST_I/RESET_OUT*" MAXDELAY = 6100 ps;


############################################################
# Crossing of Clock Domain Constraints: please do not edit #
############################################################
# Changed net name in synthesis of xps_ll_temac
# Flow Control logic reclocking - control signal is synchronised
INST "*/I_TRIMAC_INST/I_FLOW/I_RX_PAUSE/PAUSE_REQ_TO_TX"       TNM="flow_rx_to_tx";
INST "*/I_TRIMAC_INST/I_FLOW/I_RX_PAUSE/PAUSE_VALUE_TO_TX*"    TNM="flow_rx_to_tx";
TIMESPEC "TS_flow_rx_to_tx"      = FROM "flow_rx_to_tx" TO tx_clock_gmii 8000 ps DATAPATHONLY;

# generate a group of all flops NOT in the host clock domain
TIMEGRP "all_ffs"                = FFS;
TIMEGRP "ffs_except_host"        = "all_ffs" EXCEPT "host";

# Changed net name in synthesis of xps_ll_temac
# Configuration Register reclocking
INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/RX0_OUT*"            TNM="async_config";
INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/RX1_OUT*"            TNM="async_config";
INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/FC_OUT_29"           TNM="async_config";

INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/TX_OUT*"             TNM="async_config";
INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/FC_OUT_30"           TNM="async_config";

# Changed net name in synthesis of xps_ll_temac
# speed change config
INST "*/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_CONF/CNFG_SPEED*"         TNM="async_config";
INST "*/I_TRIMAC_INST/I_?XGEN/*SPEED*"                               TNM="async_config";

# Changed to comment out.  
# In BSB systems the Host_clk = PLB_CLK.  Since the CORE Gen TIG'd constraints below 
# are affecting XPS_LL_TEMAC DATAPATHONLY constraints above (at start of Soft_Ethernet_MAC constraints) 
# these paths are commented out in favor of using the DATAPATHONLY constraints.  
#TIMESPEC "TS_host_clk_to_rx_clk" = FROM "host" TO "rx_clock" TIG;
#TIMESPEC "TS_host_clk_to_tx_clk" = FROM "host" TO "tx_clock_gmii" TIG;

TIMESPEC "TS_config_to_all"      = FROM "async_config" TO "ffs_except_host" TIG;

# Changed net name in synthesis of xps_ll_temac
# Address filter specific cross clocking
INST "*/I_TRIMAC_INST/I_ADDR_FILTER_TOP/dynamic_af_gen.I_DYNAMIC_CONFIG/unicast_addr_*" TNM="addr_config_to_rx";
TIMESPEC "TS_addr_config_to_rx" = FROM "addr_config_to_rx" TO "ffs_except_host" TIG;

############################################################
# Ignore paths to resync flops
############################################################
# Changed to replace TIG with DATAPATHONLY constraints
#INST "*data_sync"                      TNM = "resync_reg";
#TIMESPEC "ts_resync_flops"       = TO "resync_reg" TIG;

# Changed - Not defined in CoreGen output and not analyzed
#TIMESPEC "ts_tx_async_regs"      = TO "tx_async_reg" TIG;

############################################################
# MDIO Constraints: please do not edit                     #
############################################################

# Changed net name in synthesis of xps_ll_temac
# Place the MDIO logic in it's own timing groups
INST "*I_TEMAC/*MII0.I_TRIMAC_CORE_?/I_TRIMAC_INST/I_RXGEN/ENABLE_REG"    TNM = "mdc_falling";
INST "*I_TEMAC/*MII0.I_TRIMAC_CORE_?/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/MIIM_READY_INT"           TNM = "mdc_rising";
INST "*I_TEMAC/*MII0.I_TRIMAC_CORE_?/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_PHY/STATE_COUNT*"  TNM = FFS "mdc_rising";
INST "*I_TEMAC/*MII0.I_TRIMAC_CORE_?/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_PHY/MDIO_TRISTATE" TNM = "mdc_falling";
INST "*I_TEMAC/*MII0.I_TRIMAC_CORE_?/I_TRIMAC_INST/MANIFGEN.I_MANAGEN/I_PHY/MDIO_OUT"           TNM = "mdc_falling";

TIMEGRP "mdio_logic"             = "mdc_rising" "mdc_falling";

TIMESPEC "TS_mdio1"              = PERIOD "mdio_logic" 400 ns;
TIMESPEC "TS_mdio2"              = FROM "mdc_rising" TO "mdc_falling" 200 ns;
TIMESPEC "TS_mdio3"              = FROM "mdio_logic" TO "host" "TS_host_clk";
TIMESPEC "TS_mdio4"              = FROM "host" TO "mdio_logic" "TS_host_clk";

# Changed net name in synthesis of xps_ll_temac
# want to TIG any timing paths to the select of the TX clock BUFGMUXs as this is always an async path
PIN "*I_CLOCK_INST*/*.BUFGMUX_SPEED_CLK.I?" TNM="clk_bufgmux";
TIMESPEC "TS_bufgmux" = FROM "async_config" TO "clk_bufgmux" TIG;




